#pragma config(Sensor, S1,     Light,          sensorEV3_Color)
#pragma config(Motor,  motorB,          Left,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          Right,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void moveStraight();
void turnRight1();
void turnRight2();
void turnLeft1();
void turnLeft2();
void detection();
void testChars();

char grid[7][9];
int rowCntr=1;
int colCntr=1;
int gridRows=0;
int gridCols=0;
string filename = "testFile";

task main()
{
	while(colCntr<10)
	{
		//	displayBigTextLine(4,"%d",colCntr);
	//	displayBigTextLine(6,"%d",rowCntr);
		for(rowCntr=1;rowCntr<7;rowCntr++)
		{
			detection();
			moveStraight();
			displayBigTextLine(6,"%d",rowCntr);
			displayBigTextLine(4,"%d",colCntr);
			gridRows++;

			if(rowCntr==6&&(colCntr==2||colCntr==4||colCntr==6||colCntr==8))
			{
				detection();
				turnRight1();
				moveStraight();
				turnRight2();
				colCntr++;
				gridCols++;
				gridRows=0;
			}
			else if(rowCntr==6)
			{
				detection();
				if(colCntr==9)
				{break;}
				turnLeft1();
				moveStraight();
				turnLeft2();
				colCntr++;
				gridCols++;
				gridRows=0;
			}
		if(rowCntr==6&&colCntr==9)
		{
			motor[motorB]=0;
		motor[motorC]=0;
			break;
		}
	}

}
//testChars();
}


void moveStraight()
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	while(nMotorEncoder[motorB] < 300 && nMotorEncoder[motorC] < 300)
	{
		motor[motorB]=30;
		motor[motorC]=30;
	}
}

void turnRight1()
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	while(nMotorEncoder[motorB]< 175)
	{
		motor[motorB]=10;
		motor[motorC]=-10;
	}

	motor[motorB]=0;
	motor[motorC]=0 ;
}

void turnRight2()
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	while(nMotorEncoder[motorB]< 172)
	{
		motor[motorB]=10;
		motor[motorC]=-10;
	}

	motor[motorB]=0;
	motor[motorC]=0 ;
}

void turnLeft1()
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	while(nMotorEncoder[motorB]> -175)
	{
		motor[motorB]=-10;
		motor[motorC]=10;
	}

	motor[motorB]=0;
	motor[motorC]=0 ;

}

void turnLeft2()
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	while(nMotorEncoder[motorB]> -172)
	{
		motor[motorB]=-10;
		motor[motorC]=10;
	}

	motor[motorB]=0;
	motor[motorC]=0 ;

}

void detection()
{
	if(SensorValue(Light)>45)
	{
		grid[gridRows][gridCols]='1';
	}
	else
	{
		grid[gridRows][gridCols]='0';
	}
}

void testChars()
{
  writeDebugStreamLine("Testing Chars");

  // The file handle, this is a reference to
  // the file you have opened
  long fileHandle;

  string string1 = "\n";
  int strlen1 = strlen(string1);
  char readValue;

  // Open the file for writing and return a handle,
  // which we can use for subsequent writes
  fileHandle = fileOpenWrite(filename);
  for (int i = 0; i < 9; i++)
  {
  	if(i==1||i==3||i==5||i==7)
  	{
  	for(int j = 6; j>-1;j--)
  	{
  	// Write a char (1 byte) value to the file, this is
  	// binary, not a string
    fileWriteChar(fileHandle, grid[j][i]);
  	}
  }
  else
  {
  		for(int j = 0; j<7;j++)
  	{
  	// Write a char (1 byte) value to the file, this is
  	// binary, not a string
    fileWriteChar(fileHandle, grid[j][i]);
  	}
  }
  fileWriteData(fileHandle, string1, strlen1);
  }
  writeDebugStreamLine("fileHandle: %d", fileHandle);

  // Close the file, this automatically flushes the
  // buffers to the "disk".
  fileClose(fileHandle);

  // Open the file for reading and return a handle.
 fileHandle = fileOpenRead(filename);

  // Read char values for as long as there's data.
  // The fileReadChar() function returns "false" when
  // an error occurred or not data is left
  while (fileReadChar(fileHandle, &readValue))
  {
    writeDebugStreamLine("Read: %d", readValue);
  }

  // Close the file
  fileClose(fileHandle);
}
