#pragma config(Sensor, S1,     Light,          sensorEV3_Color)
#pragma config(Motor,  motorB,          Left,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          Right,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void moveStraight();
void turnRight1();
void turnRight2();
void turnLeft1();
void turnLeft2();
void detection();
void testChars();
void findStart();

char grid[7][9];
int rowCntr=1;
int colCntr=1;
int gridRows=0;
int gridCols=0;
float firstPosition=0.0;
string filename = "testFile";
int blackSquares=0;

task main()
{
	findStart();
	while(colCntr<10)
	{
		//	displayBigTextLine(4,"%d",colCntr);
	//	displayBigTextLine(6,"%d",rowCntr);
		for(rowCntr=1;rowCntr<7;rowCntr++)
		{
			detection();
			moveStraight();
			displayBigTextLine(6,"%d",rowCntr);
			displayBigTextLine(4,"%d",colCntr);
			gridRows++;

			if(rowCntr==6&&(colCntr==2||colCntr==4||colCntr==6||colCntr==8))
			{
				detection();
				turnRight1();
				moveStraight();
				turnRight2();
				colCntr++;
				gridCols++;
				gridRows=0;
			}
			else if(rowCntr==6)
			{
				detection();
				if(colCntr==9)
				{break;}
				turnLeft1();
				moveStraight();
				turnLeft2();
				colCntr++;
				gridCols++;
				gridRows=0;
			}
	}
		if(rowCntr==6&&colCntr==9) //THIS IF SHOULD BE ONE CURLY BRACE LOWER YOU BIG IDIOT
		{
			motor[motorB]=0;
		motor[motorC]=0;
			break;
		}

}
testChars();
}


void moveStraight()
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	while(nMotorEncoder[motorB] < 300 && nMotorEncoder[motorC] < 300)
	{
		motor[motorB]=30;
		motor[motorC]=30;
	}
}

void turnRight1()
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	while(nMotorEncoder[motorB]< 175)
	{
		motor[motorB]=10;
		motor[motorC]=-10;
	}

	motor[motorB]=0;
	motor[motorC]=0 ;
}

void turnRight2()
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	while(nMotorEncoder[motorB]< 172)
	{
		motor[motorB]=10;
		motor[motorC]=-10;
	}

	motor[motorB]=0;
	motor[motorC]=0 ;
}

void turnLeft1()
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	while(nMotorEncoder[motorB]> -175)
	{
		motor[motorB]=-10;
		motor[motorC]=10;
	}

	motor[motorB]=0;
	motor[motorC]=0 ;

}

void turnLeft2()
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	while(nMotorEncoder[motorB]> -172)
	{
		motor[motorB]=-10;
		motor[motorC]=10;
	}

	motor[motorB]=0;
	motor[motorC]=0 ;

}

void detection()
{
	if(SensorValue(Light)>45)
	{
		grid[gridRows][gridCols]='1';
	}
	else
	{
		grid[gridRows][gridCols]='0';
		blackSquares++;
	}
}

void testChars()
{
  writeDebugStreamLine("Testing Chars");

  // The file handle, this is a reference to
  // the file you have opened
  long fileHandle;

  string string1 = "\n";
  int strlen1 = strlen(string1);
  char readValue;
  
  string string2 = "Start position is 1 ";
  int strlen2 = strlen(string2);

  // Open the file for writing and return a handle,
  // which we can use for subsequent writes
  fileHandle = fileOpenWrite(filename);
  fileWriteData(fileHandle, string2, strlen2);
  //firstPosition=1.0;
  string fp1 = firstPosition; //casts the float value as a string to bypass a printing error
  int strlenfp1 = strlen(fp1);
  fileWriteData(fileHandle, fp1, strlenfp1);
  fileWriteData(fileHandle, string1, strlen1);
  for (int i = 0; i < 9; i++)
  {
  	if(i==1||i==3||i==5||i==7)
  	{
  	for(int j = 6; j>-1;j--)
  	{
  	// Write a char (1 byte) value to the file, this is
  	// binary, not a string
    fileWriteChar(fileHandle, grid[j][i]);
  	}
  }
  else
  {
  		for(int j = 0; j<7;j++)
  	{
  	// Write a char (1 byte) value to the file, this is
  	// binary, not a string
    fileWriteChar(fileHandle, grid[j][i]);
  	}
  }
  fileWriteData(fileHandle, string1, strlen1);
  }
  writeDebugStreamLine("fileHandle: %d", fileHandle);

  // Close the file, this automatically flushes the
  // buffers to the "disk".
  fileClose(fileHandle);

  // Open the file for reading and return a handle.
 fileHandle = fileOpenRead(filename);

  // Read char values for as long as there's data.
  // The fileReadChar() function returns "false" when
  // an error occurred or not data is left
  while (fileReadChar(fileHandle, &readValue))
  {
    writeDebugStreamLine("Read: %d", readValue);
  }

  // Close the file
  fileClose(fileHandle);
}

void findStart()
 {
   	int boundary=0;
		float lineCntr=0.0;
		int sense=0;

	nMotorEncoder[motorB]=0;
	while(boundary!=1)
	{
		displayBigTextLine(4,"%f",lineCntr);
		displayBigTextLine(6,"%d",SensorValue(Light));
		displayBigTextLine(8,"%d",sense);
			motor[motorB]=30;
  		motor[motorC]=30;
  		if(SensorValue(Light)<45&&sense!=1)
			{
				if(time1(T1)<200)
				{
					turnLeft1();
					turnLeft1();
					motor[motorB]=30;
					motor[motorC]=30;
					wait1Msec(500);
					boundary=1;
					firstPosition=lineCntr;
					motor[motorB]=0;
					motor[motorC]=0;
					displayBigTextLine(10,"%f",firstPosition);
					wait1Msec(5000);
				}
				sense=1;
				nMotorEncoder[motorB]=0;
			}

			if(SensorValue(Light)>45&&sense==1)
			{
					lineCntr++;
					sense=0;
					nMotorEncoder[motorB]=0;
					clearTimer(T1);
			}


			if(sense==1&&nMotorEncoder[motorB]==290)
			{
				lineCntr++;
				nMotorEncoder[motorB]=0;
			}
		}
	}
